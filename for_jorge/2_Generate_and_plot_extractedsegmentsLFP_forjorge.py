#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Aug 20 08:15:04 2024

@author: jameslim

Code for Manuscript1_Figure3cLFP

Stimulation of dissociated cortical neurons on MED64 arrays
"""

import tkinter as tk
from tkinter import filedialog
import os
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import time
import json
import scipy.signal

from intanutil.header import (read_header,
                              header_to_result)
from intanutil.data import (calculate_data_size,
                            read_all_data_blocks,
                            check_end_of_file,
                            parse_data,
                            data_to_result)
from intanutil.filter import apply_notch_filter
counter_stim=False
#counter_stim=True

AP_IIR_Order=4
#Filter_cutoffL=1
Filter_cutoffH=300

MEA_Type='Neuronexus'
#MEA_Type='MED64'

if MEA_Type=='Neuronexus':
    max_impedance=4000000

elif MEA_Type=='MED64':
    max_impedance=300000


# Initialize a counter outside the function if needed
iteration_counter = 0 #for extracted segments folders

def read_data(filename):
    """Reads Intan Technologies RHS2000 data file generated by acquisition
    software (IntanRHX, or legacy Stimulation/Recording Controller software).

    Data are returned in a dictionary, for future extensibility.
    """
    # Start measuring how long this read takes.
    tic = time.time()
    print(filename)
    # Open file for reading.
    with open(filename, 'rb') as fid:

        # Read header and summarize its contents to console.
        header = read_header(fid)

        # Calculate how much data is present and summarize to console.
        data_present, filesize, num_blocks, num_samples = (
            calculate_data_size(header, filename, fid))

        # If .rhs file contains data, read all present data blocks into 'data'
        # dict, and verify the amount of data read.
        print('FINISHED HEADER')
        if data_present:
            data = read_all_data_blocks(header, num_samples, num_blocks, fid)
            check_end_of_file(filesize, fid)

    # Save information in 'header' to 'result' dict.
    result = {}
    header_to_result(header, result)

    # If .rhs file contains data, parse data into readable forms and, if
    # necessary, apply the same notch filter that was active during recording.
    if data_present:
        parse_data(header, data)
        apply_notch_filter(header, data)

        # Save recorded data in 'data' to 'result' dict.
        data_to_result(header, data, result)

    # Otherwise (.rhs file is just a header for One File Per Signal Type or
    # One File Per Channel data formats, in which actual data is saved in
    # separate .dat files), just return data as an empty list.
    else:
        data = []

    # Report how long read took.
    print('Done!  Elapsed time: {0:0.1f} seconds'.format(time.time() - tic))

    # Return 'result' dict.
    return result


# New function to handle the main folder processing
def process_main_folder(folder_path):
    # Process CSV and JSON files directly under the main folder
    csv_file_path = find_csv_file(folder_path)
    if csv_file_path:
        print("CSV file found:", csv_file_path)
        # Process impedance CSV file
        impedance_info = process_impedance_csv(csv_file_path)
    
    json_file_path = find_json_file(folder_path)
    if json_file_path:
        print("JSON file found:", json_file_path)
        # Process stimulation parameters JSON file
        stim_protocols= process_stim_params_json(json_file_path)
    
    # Identify and process each stim protocol subfolder
    stim_folders = find_stim_folders(folder_path)
    print(stim_folders)
    for stim_folder in stim_folders:
        print(f"Processing stim protocol folder: {stim_folder}")
        rhs_folders=find_rhs_files(stim_folder)
        for stim_group, folder_name in enumerate(rhs_folders):
            if stim_group>=8:
                plot_CD=True
            folder_full_path = os.path.join(folder_path, folder_name)
            stim_param=extract_params_from_folder_name(stim_folder)
            plots_save_path = os.path.join(folder_path, stim_folder)

            process_eight_electrode_data(plots_save_path,folder_full_path, impedance_info, stim_param,stim_protocols)



def find_csv_file(folder_path):
    # Check if the specified directory exists
    if not os.path.exists(folder_path):
        print("Directory does not exist:", folder_path)
        return None
    
    # List files in the selected folder
    files_in_folder = os.listdir(folder_path)
    
    # Search for CSV files in the selected folder
    csv_files = [file for file in files_in_folder if file.endswith('.csv')]
    
    if csv_files:
        # CSV file found, return the first one
        return os.path.join(folder_path, csv_files[0])
    else:
        print("No CSV files found in the selected folder.")
        return None
  
  
def process_impedance_csv(impedance_csv_path):
    if not impedance_csv_path:
        print("No impedance CSV file selected. Exiting.")
        exit()
    impedance_data = pd.read_csv(impedance_csv_path)

    # Assuming the first row contains header information
    frequency = impedance_data.columns[4].split()[3]  # Extract frequency from header
    print(f"The impedances have been loaded successfully. \nThe impedance measurements happened at {frequency} Hz")

    # Print channel numbers and port names
    channels = impedance_data['Channel Number'].tolist()
    num_channels = len(channels)
    ports = [channel[0] for channel in channels]
    unique_ports = sorted(set(ports))
    print("Number of channels were ", num_channels)
    print("Port names were ", unique_ports)

    impedance_magnitudes_column = next(column for column in impedance_data.columns if column.startswith("Impedance Magnitude at "))
    impedance_magnitudes = impedance_data[impedance_magnitudes_column].tolist()
    impedance_magnitudes_integers = [int(x) for x in impedance_magnitudes]

    impedance_phase_column = next(column for column in impedance_data.columns if column.startswith("Impedance Phase at "))
    impedance_phase = impedance_data[impedance_phase_column].tolist()
    impedance_resistance = impedance_data['Series RC equivalent R (Ohms)'].tolist()
    impedance_capacitance = impedance_data['Series RC equivalent C (Farads)'].tolist()

    # Consolidate the impedance data into a single dictionary
    impedance_info = {
        "frequency": frequency,
        "channels": channels,
        "num_channels": num_channels,
        "ports": unique_ports,
        "impedance_magnitudes_column": impedance_magnitudes_column,
        "impedance_magnitudes": impedance_magnitudes,
        "impedance_magnitudes_integers": impedance_magnitudes_integers,
        "impedance_phase_column": impedance_phase_column,
        "impedance_phase": impedance_phase,
        "impedance_resistance": impedance_resistance,
        "impedance_capacitance": impedance_capacitance
    }

    return impedance_info


def find_json_file(folder_path):
    for file in os.listdir(folder_path):
        if file.endswith('.json'):
            return os.path.join(folder_path, file)
    return None

def process_stim_params_json(json_file_path):
    if json_file_path:
        with open(json_file_path, 'r') as json_file:
            json_data = json.load(json_file)
        print("JSON file data:")
        print("Currents List:", json_data['currents_list'])
        print("Pulse Counts List:", json_data['pulse_counts_list'])
        print("Pulse Widths List:", json_data['pulse_widths_list'])
        print("Interstim Delay:", json_data['Interstim_Delay'])
        print("Polarity Options:", json_data['Polarity_Options'])
        #print("Active Ports:", json_data['ActivePorts'])
        print("Pulse Shapes:", json_data['Pulse_Shapes'])
        print("Sampling Rate:", json_data['sampleRate'])

    else:
        print("No JSON file found in the selected folder.")
    return json_data


def find_stim_folders(directory):
    # Identifies and returns paths to folders matching the stim protocol pattern
    stim_folders = [os.path.join(directory, d) for d in os.listdir(directory) if os.path.isdir(os.path.join(directory, d)) and d.startswith('STIM_')]
    return stim_folders


def process_stim_protocol_folder(stim_folder, impedance_data, stim_param):
    # Identify subfolders for electrode data and process each
    electrode_folders = [os.path.join(stim_folder, d) for d in os.listdir(stim_folder) if os.path.isdir(os.path.join(stim_folder, d))]
    print(stim_param)
    #print(impedance_data)

    for electrode_folder in electrode_folders:
        print(f"Processing electrode data in folder: {electrode_folder}")
        
        

def extract_params_from_folder_name(folder_name):
    """
    Extracts stimulation parameters from the stimulation protocol folder name.

    Parameters:
    - folder_name (str): The name of the folder, following a convention like
      "STIM_C1.0_PC1.0_PW0.033_PositiveFirst_PS2".

    Returns:
    - dict: A dictionary containing the extracted parameters with their values.
    """
    # Dictionary to hold the extracted parameters
    extracted_params = {}

    # Removing the 'STIM_' prefix and splitting the rest by underscores
    parts = folder_name.split('_')

    # Mapping of parameter prefixes in folder names to their dictionary keys
    param_mapping = {
        'CC': 'current',
        'PC': 'pulse_count',
        'PW': 'pulse_width',
        'PositiveFirst': 'polarity',
        'NegativeFirst': 'polarity',  # Adjust based on actual possible values
        'PS': 'pulse_shape',
        'CS': 'Counter_Stim',
    }

    # Loop through each part of the split folder name
    for part in parts:
        # Check each possible parameter prefix
        for prefix, key in param_mapping.items():
            if part.startswith(prefix):
                # Special handling for polarity to keep it as string
                if prefix in ['PositiveFirst', 'NegativeFirst']:
                    extracted_params[key] = part
                else:
                    # Extract and convert numerical values
                    value = part[len(prefix):]  # Remove the prefix
                    print(f"key={key} value={value}")
                    
                    extracted_params[key] = float(value) if '.' in value else int(value)
                break  # Move to the next part after processing

    return extracted_params


def find_rhs_files(directory):
    rhs_folders = set()  # Use a set to avoid duplicate folder names
    print(f"directory={directory}")
    for root, dirs, files in (os.walk(directory)):
        for file in files:
            if file.endswith('.rhs'):
                print(f'file found: {file}')
                #folder_name = os.path.basename(root)
                #folder_path=os.path.join(root, folder_name)
                folder_path=root
                rhs_folders.add(folder_path)
                break  # Stop iterating through files in this folder once a .rhs file is found
            else:
                pass
            
    return sorted(rhs_folders)


def process_eight_electrode_data(plots_save_path,electrode_folder, impedance_info, stim_param,stim_protocols):
    """
    Process .rhs files in a given electrode folder, detect stimulation events,
    and plot data for groups of 8 electrodes.

    Parameters:
    - electrode_folder (str): The path to the electrode folder.
    - impedance_data (dict): Dictionary containing impedance-related data.
    - stim_param (dict): Dictionary containing stimulation parameters.
    """
                
                
    print(stim_param)        
    concatenated_signal = None
    concatenated_board_dig_in_data = None
    Stim_Channel_start=extract_electrode_number(os.path.basename(electrode_folder))

    for file_name in sorted(os.listdir(electrode_folder)):
        print(f'file name= {file_name}')
        if file_name.endswith('.rhs'):
            file_path = os.path.join(electrode_folder, file_name)
            rhs_data = read_data(file_path)  # Assuming this returns a dict with necessary data

            # Concatenate data across files
            if concatenated_signal is None:
                concatenated_signal = rhs_data['amplifier_data']
                concatenated_board_dig_in_data = rhs_data['board_dig_in_data']
            else:
                concatenated_signal = np.concatenate((concatenated_signal, rhs_data['amplifier_data']), axis=1)
                concatenated_board_dig_in_data = np.concatenate((concatenated_board_dig_in_data, rhs_data['board_dig_in_data']), axis=1)
    No_of_Channels=len(rhs_data['amplifier_data'])
    print(f'No of channels={No_of_Channels}')
       
    filters = [Filter(stim_protocols['sampleRate'], Filter_cutoffH) for _ in range(No_of_Channels)]
    concatenated_signal_low_pass = np.empty_like(concatenated_signal)
    
    downsample_factor = 15  # 30kHz / 15 = 2kHz
    concatenated_signal_low_pass_ds = np.zeros((No_of_Channels, concatenated_signal.shape[1] // downsample_factor))
    
    for N in range(No_of_Channels):
        # Filter the signal
        concatenated_signal_low_pass[N, :] = filters[N].AP_IIR(concatenated_signal[N, :])
        # Downsample the filtered signal and store it in the concatenated_signal_low_pass_ds array
        decimated_signal = scipy.signal.decimate(concatenated_signal_low_pass[N, :], downsample_factor, axis=0)
        concatenated_signal_low_pass_ds[N, :] = decimated_signal[:concatenated_signal_low_pass_ds.shape[1]]
    # Find stimulation events
    for sch in range (8):
        Stim_channel=Stim_Channel_start+sch
        crossings = find_stim(concatenated_board_dig_in_data[sch])
        print(f'The number of stims in channel {Stim_channel} is {len(crossings)}')
        window_before = int(2 * stim_protocols['sampleRate'])  # 0.2 seconds before threshold crossing
        window_after = int(5 * stim_protocols['sampleRate'])   # 0.8 seconds after threshold crossing
        window_before_z = int(2 * stim_protocols['sampleRate'])  # 0.2 seconds before threshold crossing
        window_after_z = int(5 * stim_protocols['sampleRate'])   # 0.8 seconds after threshold crossing
        window_before_z2 = int(1 * stim_protocols['sampleRate'])  # 0.2 seconds before threshold crossing
        window_after_z2 = int(4 * stim_protocols['sampleRate'])   # 0.8 seconds after threshold crossing

        # Initialize a list to store extracted segments
        extracted_segments = []
        extracted_segments_f = []
        extracted_segments_f_z = []
        extracted_segments_f_z2 = []
        time_range_ds = []
        
        i=0
        # Iterate over threshold crossings
        for crossing in (crossings):
            # Define the start and end indices for the window
            # start_index = max(0, crossing - window_before)
            # end_index = min(len(concatenated_signal_low_pass_ds[0]), crossing+window_after)

            start_index_z = max(0, crossing - window_before_z)
            end_index_z = min(len(concatenated_signal[0]), crossing+window_after_z)

            start_index_z2 = max(0, crossing - window_before_z2)
            end_index_z2 = min(len(concatenated_signal[0]), crossing+window_after_z2)

            # Extract the segment from the concatenated signal

            # segment = concatenated_signal[:, start_index:end_index]
            # segment_ds = scipy.signal.decimate(segment, downsample_factor, axis=1)
            # # Append the segment to the list
            # extracted_segments.append(segment_ds) 

            # segment_f = concatenated_signal_low_pass[:, start_index:end_index]
            # segment_f_ds = scipy.signal.decimate(segment_f, downsample_factor, axis=1)
            # Append the segment to the list
            # extracted_segments_f.append(segment_f_ds)

            segment_f_z = concatenated_signal_low_pass[:, start_index_z:end_index_z]
            segment_f_z_ds = scipy.signal.decimate(segment_f_z, downsample_factor, axis=1)
            # Append the segment to the list
            extracted_segments_f_z.append(segment_f_z_ds)

            # segment_f_z2 = concatenated_signal_low_pass[:, start_index_z2:end_index_z2]
            # segment_f_z2_ds = scipy.signal.decimate(segment_f_z2, downsample_factor, axis=1)
            # # Append the segment to the list
            # extracted_segments_f_z2.append(segment_f_z2_ds)

        # outputs_folder = os.path.join(plots_save_path, "Outputs_raw_LFP")
        # plot_single_electrode(outputs_folder, extracted_segments, Stim_channel, stim_protocols,impedance_info,stim_param)
        # # save_arrays(extracted_segments,outputs_folder,Stim_channel)
        
        # outputs_folder_f = os.path.join(plots_save_path, "Outputs_LFP")
        # plot_single_electrode(outputs_folder_f, extracted_segments_f, Stim_channel, stim_protocols,impedance_info,stim_param)
        # # save_arrays(extracted_segments_f,outputs_folder_f,Stim_channel)
        
        outputs_folder_f_z = os.path.join(plots_save_path, "Outputs_LFP_zoomed")
        plot_single_electrode(outputs_folder_f_z, extracted_segments_f_z, Stim_channel, stim_protocols,impedance_info,stim_param)
        save_arrays(extracted_segments_f_z,outputs_folder_f_z,Stim_channel)
        
        outputs_folder_f_z2 = os.path.join(plots_save_path, "Outputs_LFP_zoomed_2")
        # plot_single_electrode(outputs_folder_f_z2, extracted_segments_f_z2, Stim_channel, stim_protocols,impedance_info,stim_param)
        # save_arrays(extracted_segments_f_z2,outputs_folder_f_z2,Stim_channel)

        
    
def save_arrays(array,outputs_folder,Stim_channel):
        
    global iteration_counter  # Ensure the counter is accessible within the function
    
     # Increment the counter for each iteration
    iteration_counter += 1
    
    # Save your array (replace `extracted_segments` with your actual array variable)
    # np.save(npy_save_path, extracted_segments)
     # Define the name of the new folder you want to create inside stim_folder
     

    
     # os.makedirs(outputs_folder, exist_ok=True)
     ###plot_filename = os.path.join(outputs_folder, 'extracted_segments_f_AP')
     # Save each array with a unique filename
    file_name=f"extracted_segments_LFP_Ch{Stim_channel}.npy" # for if you just want channel number
    # file_name=f"extracted_segments_LFP_{Stim_Channel_Name}.npy"
    os.makedirs(outputs_folder, exist_ok=True)
    np.save(os.path.join(outputs_folder, file_name), array)
    
    print('Extracted_segments saved!')
    '''James added to test saving extracted segments array'''
     
    
def extract_electrode_number(folder_name):
    """
    Extracts the absolute electrode number from the folder name.
    
    Parameters:
    - folder_name (str): The name of the folder, e.g., 'A-000-A-007_240318_144246'
    
    Returns:
    - int: The absolute electrode number (across all groups A-D).
    """
    # Split the folder name on underscores (_) and take the first part
    first_part = folder_name.split('_')[0]
    # Extract the group (A-D) and the starting electrode number within the group
    group, start_num = first_part.split('-')[0], int(first_part.split('-')[1])
    
    # Define a mapping from group to its starting absolute electrode number
    group_to_number = {'A': 0, 'B': 32, 'C': 64, 'D': 96}
    
    # Calculate the absolute electrode number
    absolute_electrode_number = group_to_number.get(group, 0) + start_num
    
    return absolute_electrode_number #if files start with port A
    #return absolute_electrode_number-64 #if files start with port C

def plot_single_electrode(outputs_folder,extracted_segments,Stim_Channel,stim_protocols,impedance_info,stim_param):
    fig, axs = plt.subplots(8, 8, figsize=(16, 16), squeeze=True)
    if MEA_Type=='MED64':
        if Stim_Channel<64:
            start=0
            layout = [
                        ['A22', 'B18', 'B30', 'B24', 'B1',  'B3',  'B5',  'B23'],
                        ['A23', 'B20', 'B16', 'B26', 'B25', 'B27', 'B22', 'A24'],
                        ['B21', 'B14', 'B15', 'B28', 'B2',  'B4',  'A0',  'A1' ],
                        ['B19', 'B12', 'B13', 'B11', 'B0',  'A25', 'A2',  'A3' ],
                        ['B10', 'B17', 'B9',  'A14', 'A26', 'A27', 'A5',  'A4' ],
                        ['B8',  'B31', 'A30', 'A20', 'A12', 'A29', 'A7',  'A6' ],
                        ['B7',  'B6',  'A16', 'A21', 'A13', 'A11', 'A31', 'A8' ],
                        ['B29', 'A28', 'A18', 'A15', 'A19', 'A17', 'A10', 'A9' ]
                    ]
        elif Stim_Channel>=64:
            start=64
            layout = [
                        ['C22', 'D18', 'D30', 'D24', 'D1',  'D3',  'D5',  'D23'],
                        ['C23', 'D20', 'D16', 'D26', 'D25', 'D27', 'D22', 'C24'],
                        ['D21', 'D14', 'D15', 'D28', 'D2',  'D4',  'C0',  'C1' ],
                        ['D19', 'D12', 'D13', 'D11', 'D0',  'C25', 'C2',  'C3' ],
                        ['D10', 'D17', 'D9',  'C14', 'C26', 'C27', 'C5',  'C4' ],
                        ['D8',  'D31', 'C30', 'C20', 'C12', 'C29', 'C7',  'C6' ],
                        ['D7',  'D6',  'C16', 'C21', 'C13', 'C11', 'C31', 'C8' ],
                        ['D29', 'C28', 'C18', 'C15', 'C19', 'C17', 'C10', 'C9' ]
                    ]
    elif MEA_Type=='Neuronexus':
        if Stim_Channel<64:
            start=0
            layout = [
                        ['A7', 'A6', 'A14', 'A20', 'B24', 'B25', 'B17', 'B11'],
                        ['A0', 'A4', 'A13', 'A22', 'B31', 'B27', 'B18', 'B9'],
                        ['A23', 'A17', 'A27', 'A11', 'B6', 'B30', 'B10', 'B20'],
                        ['A31', 'A19', 'A12', 'A18', 'B0', 'B2', 'B19', 'B13'],
                        ['A28', 'A2', 'A29', 'A15', 'B3', 'B29', 'B12', 'B16'],
                        ['A5', 'A21', 'A1', 'A25', 'B26', 'B4', 'B14', 'B8'],
                        ['A24', 'A3', 'A10', 'A16', 'B7', 'B28', 'B21', 'B15'],
                        ['A26', 'A30', 'A8', 'A9', 'B5', 'B1', 'B23', 'B22']
                    ]

        elif Stim_Channel>=64:
            start=64
            layout = [
                        ['C7', 'C6', 'C14', 'C20', 'D24', 'D25', 'D17', 'D11'],
                        ['C0', 'C4', 'C13', 'C22', 'D31', 'D27', 'D18', 'D9'],
                        ['C23', 'C17', 'C27', 'C11', 'D6', 'D30', 'D10', 'D20'],
                        ['C31', 'C19', 'C12', 'C18', 'D0', 'D2', 'D19', 'D13'],
                        ['C28', 'C2', 'C29', 'C15', 'D3', 'D29', 'D12', 'D16'],
                        ['C5', 'C21', 'C1', 'C25', 'D26', 'D4', 'D14', 'D8'],
                        ['C24', 'C3', 'C10', 'C16', 'D7', 'D28', 'D21', 'D15'],
                        ['C26', 'C30', 'C8', 'C9', 'D5', 'D1', 'D23', 'D22']
                    ]
# def plot_single_electrode(outputs_folder, extracted_segments, Stim_Channel, stim_protocols, impedance_info, stim_param):
#     fig, axs = plt.subplots(8, 8, figsize=(16, 16), squeeze=True)

#     if MEA_Type == 'MED64':
#         if Stim_Channel < 64:
#             print("Ignoring Stim_Channel < 64 as only channels 64–128 are considered.")
#             return  # Skip processing for channels 0–63
#         else:  # Stim_Channel >= 64
#             start = 64
#             layout = [
#                 ['C22', 'D18', 'D30', 'D24', 'D1', 'D3', 'D5', 'D23'],
#                 ['C23', 'D20', 'D16', 'D26', 'D25', 'D27', 'D22', 'C24'],
#                 ['D21', 'D14', 'D15', 'D28', 'D2', 'D4', 'C0', 'C1'],
#                 ['D19', 'D12', 'D13', 'D11', 'D0', 'C25', 'C2', 'C3'],
#                 ['D10', 'D17', 'D9', 'C14', 'C26', 'C27', 'C5', 'C4'],
#                 ['D8', 'D31', 'C30', 'C20', 'C12', 'C29', 'C7', 'C6'],
#                 ['D7', 'D6', 'C16', 'C21', 'C13', 'C11', 'C31', 'C8'],
#                 ['D29', 'C28', 'C18', 'C15', 'C19', 'C17', 'C10', 'C9']
#             ]
#     elif MEA_Type == 'Neuronexus':
#         if Stim_Channel < 64:
#             print("Ignoring Stim_Channel < 64 as only channels 64–128 are considered.")
#             return  # Skip processing for channels 0–63
#         else:  # Stim_Channel >= 64
#             start = 64
#             layout = [
#                 ['C7', 'C6', 'C14', 'C20', 'D24', 'D25', 'D17', 'D11'],
#                 ['C0', 'C4', 'C13', 'C22', 'D31', 'D27', 'D18', 'D9'],
#                 ['C23', 'C17', 'C27', 'C11', 'D6', 'D30', 'D10', 'D20'],
#                 ['C31', 'C19', 'C12', 'C18', 'D0', 'D2', 'D19', 'D13'],
#                 ['C28', 'C2', 'C29', 'C15', 'D3', 'D29', 'D12', 'D16'],
#                 ['C5', 'C21', 'C1', 'C25', 'D26', 'D4', 'D14', 'D8'],
#                 ['C24', 'C3', 'C10', 'C16', 'D7', 'D28', 'D21', 'D15'],
#                 ['C26', 'C30', 'C8', 'C9', 'D5', 'D1', 'D23', 'D22']
#             ]
            
            
    # Initialize lists outside the loop
    mean_segments = []
    rms_segments = []
    std_segment = []
    # legend_labels = ['Mean', 'RMS','STD']
    legend_labels = ['Mean','STD']
    legend_handles = []
    # RMS_on_mean = []
    print([arr.shape for arr in extracted_segments])

    mean_segments=np.mean(extracted_segments, axis=0)
    rms_segments=np.sqrt(np.mean(np.square(extracted_segments), axis=0))
    std_segment=np.std(extracted_segments, axis=0)
    # RMS_on_mean=RMS(mean_segments)
    min_value = np.minimum(np.min(mean_segments), np.min(rms_segments))
    # min_value = np.minimum(np.min(mean_segments))
    max_value = np.maximum(np.max(mean_segments), np.max(rms_segments))
    # max_value = np.maximum(np.max(mean_segments))

    if outputs_folder[-6:]=='zoomed':
      min_value=-200
      max_value=200
    if outputs_folder[-8:]=='zoomed_2':
      min_value=-100
      max_value=100
    print(f'start electrode:{start}')
    Stim_Channel_Name=get_channel_name(Stim_Channel)
    if counter_stim:
        counter_electrode=int(Stim_Channel_Name[1:])+8
        if counter_electrode>31:
            counter_electrode=counter_electrode-32
        counter_electrode_name=f'{Stim_Channel_Name[0]}{counter_electrode}'
    
    for mch in range(start, start + 64):
    # Calculate time range
        time_range = np.arange(0, len(mean_segments[mch]) / stim_protocols['sampleRate'], 1 / stim_protocols['sampleRate'])
        Channel = get_channel_name(mch)
    
        # Find the position of stim channel
        for row_idx, roww in enumerate(layout):
            for col_idx, item in enumerate(roww):
                if item == Channel:
                    row = row_idx
                    col = col_idx
                    break
    
        if float(impedance_info['impedance_magnitudes'][mch]) > max_impedance:
            # Clear the axis and conserve the layout for high impedance channels
            axs[row, col].axis('off')  # Turn off the axis for this subplot
            continue
    
        # Plot data if impedance is within acceptable limits
        axs[row, col].plot(1000 * time_range, mean_segments[mch], color='black', label='Mean')
        axs[row, col].fill_between(1000 * time_range, 
                                   mean_segments[mch] - std_segment[mch], 
                                   mean_segments[mch] + std_segment[mch], 
                                   alpha=0.6, color='blue')
        """remove axes labels for subplot 0,0"""
        # if row == 0 and col == 0:
        #     # Keep ticks and axis values only for the first time-series plot
        #     axs[row, col].set_ylabel('µV')
        #     axs[row, col].set_xlabel('ms')
        #     axs[row, col].tick_params(left=True, bottom=True, labelleft=True, labelbottom=True)
        # else:
        # Remove ticks and axis values for other time-series plots
        axs[row, col].spines['top'].set_visible(False)
        axs[row, col].spines['right'].set_visible(False)
        axs[row, col].spines['left'].set_visible(False)
        axs[row, col].spines['bottom'].set_visible(False)
        axs[row, col].tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)
        axs[row, col].set_xticks([])
        axs[row, col].set_yticks([])
    
        if mch == Stim_Channel:
            axs[row, col].set_facecolor('lightcoral')
            Stim_Channel_Name = Channel
            
    # for mch in range(start,start+64):
    #     # Calculate time range
    #     time_range = np.arange(0, len(mean_segments[mch]) / stim_protocols['sampleRate'], 1 / stim_protocols['sampleRate'])
    #     Channel=get_channel_name(mch)
    #     # Find the position of stim channel
    #     for row_idx, roww in enumerate(layout):
    #         for col_idx, item in enumerate(roww):
    #             if item == Channel:
    #                 row=row_idx
    #                 col=col_idx
    #                 break
                
    #     # title = f"{Channel}    Z={format_impedance_magnitude(impedance_info['impedance_magnitudes'][mch])}    Ph={impedance_info['impedance_phase'][mch]} \n R={format_impedance_magnitude(impedance_info['impedance_resistance'][mch])} C={format_capacitance_magnitude(impedance_info['impedance_capacitance'][mch])} RMS={RMS_on_mean[mch]:.2f}"
    #     # title = f"{Channel}"

    #     axs[row, col].plot(1000*time_range, mean_segments[mch], color='black', label='Mean')
    #     # axs[row, col].plot(1000*time_range, rms_segments[mch], color='blue', label='RMS')
    #     axs[row, col].fill_between(1000*time_range, mean_segments[mch] - std_segment[mch], mean_segments[mch] + std_segment[mch], alpha=0.6, color='blue')
    #     if row == 0 and col == 0:
    #         # Keep ticks and axis values only for the first time-series plot
    #         axs[row, col].set_ylabel('µV')
    #         axs[row, col].set_xlabel('ms')
    #         # axs[row, col].tick_params(axis='both', which='both', labelsize=20)
    #         axs[row, col].tick_params(left=True, bottom=True, labelleft=True, labelbottom=True)  # Enable tick marks and labels
    #     else:
    #         # Remove ticks and axis values for other time-series plots
    #         axs[row, col].spines['top'].set_visible(False)
    #         axs[row, col].spines['right'].set_visible(False)
    #         axs[row, col].spines['left'].set_visible(False)
    #         axs[row, col].spines['bottom'].set_visible(False)
    #         axs[row, col].tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)  # Disable tick marks and labels
    #         axs[row, col].set_xticks([])
    #         axs[row, col].set_yticks([])
    #     # if float(impedance_info['impedance_magnitudes'][mch])>max_impedence:
    #     #     # axs[row, col].set_title(title, fontsize=7, bbox=dict(facecolor='red', alpha=0.5))
    #     #     axs[row, col].set_title(title, fontsize=7, bbox=dict(facecolor='gray', alpha=0.5))
    #     #     # axs[row, col].set_facecolor('black')
    #     # else:
    #     #     axs[row, col].set_title(title, fontsize=7, bbox=dict(facecolor='gray', alpha=0.5))
    #     # axs[row, col].tick_params(axis='y', labelrotation=90)
    
    #     # if mch == start:
    #     #     legend_handles.append(axs[row, col].plot([], [], color='black')[0])
    #     #     legend_handles.append(axs[row, col].plot([], [], color='blue')[0])        
    #     #     legend_handles.append(axs[row, col].plot([], [], color='gray')[0])
    #     if mch == Stim_Channel:
    #         axs[row, col].set_facecolor('lightcoral')
    #         Stim_Channel_Name=Channel
        # if counter_stim:
        #     if counter_electrode_name==Channel:
        #         axs[row, col].set_facecolor('lightblue')
    
    #     axs[row, col].set_xlabel('s')
    #     axs[row, col].set_ylabel('uV')
    
        # Set y-axis limits
    
        if min_value>0:
                axs[row, col].set_ylim(0.8*min_value, 1.2*max_value)
        else:
                axs[row, col].set_ylim(1.2*min_value, 1.2*max_value)
    
        # axs[row, col].grid(True)
        # axs[row, col].tick_params(left=False, bottom=False) # Remove axes ticks
        # axs[row, col].set_xticks([])  # Remove x-axis values
        # axs[row, col].set_yticks([])  # Remove y-axis values
    fig.text(0.5, -0.02, 'ms', ha='center', va='center')
    fig.text(-0.02, 0.5, r'$\mu$V', ha='center', va='center', rotation='vertical')
    
    # if outputs_folder[-3:]=='raw':
    #   fig.text(0.1, 1.03, f'Raw Signal on {MEA_Type} MEA', ha='left', va='center')
    
    # elif outputs_folder[-9:]=='Outputs_High_Pass':
    #   fig.text(0.1, 1.03, f'Signals on {MEA_Type} MEA', ha='left', va='center')
    #   fig.text(0.1, 1.02, f'Signals are high pass filtered between {Filter_cutoffL}Hz and {Filter_cutoffH}Hz', ha='left', va='center')
    #   fig.text(0.1, 1.01, f'using an IIR filter of order {AP_IIR_Order}.', ha='left', va='center')
    
    # elif outputs_folder[-16:]=='Outputs_High_Pass_zoomed':
    #   fig.text(0.1, 1.03, f'Zoomed-in view of signals on {MEA_Type} MEA', ha='left', va='center')
    #   fig.text(0.1, 1.02, f'Signals are high pass filtered between {Filter_cutoffL}Hz and {Filter_cutoffH}Hz', ha='left', va='center')
    #   fig.text(0.1, 1.01, f'using an IIR filter of order {AP_IIR_Order}.', ha='left', va='center')
            
    # elif outputs_folder[-18:]=='Outputs_High_Pass_zoomed_2':
    #   fig.text(0.1, 1.03, f'Zoomed-in_2 view of signals on {MEA_Type} MEA', ha='left', va='center')
    #   fig.text(0.1, 1.02, f'Signals are high pass filtered between {Filter_cutoffL}Hz and {Filter_cutoffH}Hz', ha='left', va='center')
    #   fig.text(0.1, 1.01, f'using an IIR filter of order {AP_IIR_Order}.', ha='left', va='center')
            
    # if counter_stim:
    #     fig.text(0.55, 1.05, f'Stimulated Electrode {Stim_Channel_Name} (Highlighted lightcoral)', ha='left', va='center')
    #     fig.text(0.55, 1.04, f'Counter Stimulated Electrode {counter_electrode_name} (Highlighted lightblue)', ha='left', va='center')
    # else:
    #     fig.text(0.55, 1.04, f'Stimulated Electrode {Stim_Channel_Name} (Highlighted lightcoral)', ha='left', va='center')
    
    # if (stim_param['polarity'][0]!='P'):
    #     First='Negative'
    #     Second='Positive'  
    # else:
    #     First='Positive'
    #     Second='Negative'       
    
    
    # fig.text(0.55, 1.03, f"First Phase: {First} {stim_param['current']:.2f}uA, {stim_param['pulse_width']:.2f}us", ha='left', va='center')
    
    # fig.text(0.55, 1.02, f"Second Phase: {Second} {(stim_param['current']*float(stim_param['pulse_shape'])):.2f}uA, {(stim_param['pulse_width']/float(stim_param['pulse_shape'])):.2f}us", ha='left', va='center')
    # fig.text(0.55, 1.01, f"Largest RMS was on Channel {get_channel_name(np.argmax(RMS_on_mean))}={np.max(RMS_on_mean):.2f}", ha='left', va='center')
    
    if MEA_Type=='MED64':
      fig.text(1.04, 1.04, 'A-GND', fontsize=12, fontweight='bold', ha='center', va='center', transform=fig.transFigure, bbox=dict(facecolor='red', alpha=0.5))
      fig.text(-0.04, 1.04, 'B-REF', fontsize=12, fontweight='bold',ha='center', va='center', transform=fig.transFigure, bbox=dict(facecolor='blue', alpha=0.5))
      fig.text(1.04, -0.04, 'A-REF', fontsize=12, fontweight='bold',ha='center', va='center', transform=fig.transFigure, bbox=dict(facecolor='blue', alpha=0.5))
      fig.text(-0.04, -0.04, 'B-GND', fontsize=12, fontweight='bold',ha='center', va='center', transform=fig.transFigure, bbox=dict(facecolor='red', alpha=0.5))
    
    
    
    fig.legend(legend_handles, legend_labels, loc='upper center')
    
    plt.tight_layout()
    # Set plot size in percent
    # Set plot size in percent
    os.makedirs(outputs_folder, exist_ok=True)
    plot_filename = os.path.join(outputs_folder, f'figures_for_stim_channel_{Stim_Channel_Name}.jpg')
    plt.savefig(plot_filename, dpi=300, bbox_inches='tight', pad_inches=0.5)
    
    #plt.savefig(f'figures_for_stim_channel_{Stim_Channel_Name}.jpg', dpi=300, bbox_inches='tight', pad_inches=0.5)
    print(f'plot saved on figures_for_stim_channel_{Stim_Channel_Name}.jpg on {plot_filename}')
    #plt.show()


def RMS(data):
    rms_values = []
    for Data in data:
        rms = np.sqrt(np.mean(np.square(Data)))
        rms_values.append(rms)
    return rms_values

class Filter:
    def __init__(self,sampleRate,cutoff):
        nyq = 0.5 * sampleRate 
        self.cutoff=cutoff
        normal_cutoff = self.cutoff / nyq
        self.b, self.a = scipy.signal.iirfilter(AP_IIR_Order,normal_cutoff, btype='lowpass', analog=False, ftype='butter')
        #return b , a 


    def AP_IIR(self, data):
        y_lfilter = scipy.signal.lfilter(self.b, self.a, data) 
        return y_lfilter
    

def get_channel_name(mch):

    if mch<32:
        Channel=f'A{mch}'
    elif mch<32*2:
        Channel=f'B{mch-32}'
    elif mch<32*3:
        Channel=f'C{mch-32*2}'
    elif mch<32*4:
        Channel=f'D{mch-32*3}'
    return Channel

def format_impedance_magnitude(magnitude):
    if magnitude >= 1000000:
        return f"{(magnitude / 1000000):.1f}M"
    elif magnitude >= 1000:
        return f"{(magnitude / 1000):.1f}K"
    elif magnitude <= -1000000:
        return f"{(magnitude / 1000000):.1f}M"
    elif magnitude <= -1000:
        return f"{(magnitude / 1000):.1f}K"
    else:
        return str(magnitude)

def format_capacitance_magnitude(magnitude):
    if magnitude <= 0.000001:
        return f"{(magnitude * 1000000000):.2f}nF"
    elif magnitude <= 0.001:
        return f"{(magnitude * 1000000):.2f}uF"
    else:
        return str(magnitude)


    # Here, implement logic to segment data around stim_indices and plot as needed
    # This is where you might call plot_8_groups or similar, passing segmented data

def find_stim(array):
    true_indexes = []  # List to store the indexes of True values
    i = 0
    while i < len(array):
        if array[i]:
            true_indexes.append(i)  # Append index to the list
            i += 1000  # Skip the next 100 values
        else:
            i += 1
    return true_indexes


def main():
    root = tk.Tk()
    root.withdraw()  # Hide the main window
    folder_path = filedialog.askdirectory(title="Select the main folder")
    if folder_path:
        process_main_folder(folder_path)

if __name__ == "__main__":
    main()